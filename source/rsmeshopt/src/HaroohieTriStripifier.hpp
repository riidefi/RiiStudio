#pragma once

#include <assert.h>
#include <rsl/Types.hpp>
#include <span>
#include <vector>

namespace HaroohiePals {

// API based on draco::MeshStripifier
class TriangleStripifier {
public:
  TriangleStripifier() = default;
  ~TriangleStripifier() = default;

  // Generate triangle fans for a given mesh and output them to the output
  // iterator |out_it|. In most cases |out_it| stores the values in a buffer
  // that can be used directly on the GPU. Note that the algorithm can generate
  // multiple strips to represent the whole mesh. In such cases multiple strips
  // are separated using a so-called primitive restart index, specified by
  // |primtive_restart_index| (usually defined as the maximum allowed value for
  // the given type).
  // https://www.khronos.org/opengl/wiki/Vertex_Rendering#Primitive_Restart
  template <typename OutputIteratorT, typename IndexTypeT>
  bool
  GenerateTriangleStripsWithPrimitiveRestart(std::span<const u32> mesh,
                                             IndexTypeT primitive_restart_index,
                                             OutputIteratorT out_it);

  // Returns the number of strips generated by the last call of the
  // GenerateTriangleStripsWithPrimitiveRestart() methods.
  int num_strips() const { return num_strips_; }

private:
  int num_strips_{};

  // If indices.size() == 3 -> TRIANGLES; else TRIANGLE_STRIP. No quad support.
  std::vector<std::vector<int>>
  implTriangleStripify(std::span<const int> indices);
};

template <typename OutputIteratorT, typename IndexTypeT>
bool TriangleStripifier::GenerateTriangleStripsWithPrimitiveRestart(
    std::span<const u32> mesh, IndexTypeT primitive_restart_index,
    OutputIteratorT out_it) {
  std::vector<int> indices(mesh.size());
  for (size_t n = 0; n < mesh.size(); ++n) {
    if (static_cast<u32>(static_cast<int>(mesh[n])) != mesh[n]) {
      return false;
    }
    indices[n] = static_cast<int>(mesh[n]);
  }
  auto strips = implTriangleStripify(indices);
  bool first = true;
  for (auto& strip : strips) {
    if (first) {
      first = false;
    } else {
      *out_it++ = primitive_restart_index;
    }
    for (int x : strip) {
      assert(static_cast<int>(static_cast<u32>(x)) == x);
      *out_it++ = static_cast<u32>(x);
    }
  }
  return true;
}

} // namespace HaroohiePals
